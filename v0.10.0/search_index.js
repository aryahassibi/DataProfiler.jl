var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API","title":"API Reference","text":"This page lists the public API and links to full docstrings with examples. The quick list below is readable even without building the docs.","category":"section"},{"location":"api.html#Public-API-(quick-list)","page":"API","title":"Public API (quick list)","text":"profile(df; sample_rows=1000, maxplots=8, outdir=\"profile_artifacts\", by=nothing) — generate a comprehensive data profile and return a ProfileReport.\nrender_markdown(report) — render a profile report as Markdown text.\nsave_report(report, path; fmt=:auto) — write Markdown or HTML to disk.\nprofile_column(x; name::Symbol, is_categorical=false) — build a ColumnProfile for one column.\noutlier_flags(x; method=:mad, z=3.5) — boolean mask of numeric outliers (MAD or IQR).\nmissing_summary(x) — count and fraction of missings plus first run starts.\ndup_summary(df; by=nothing) — duplicate rows summary (optionally by keys).\n\nTypes\n\nProfileReport — top-level profiling result with dataset and column summaries.\nColumnProfile — per-column profile with stats, notes, and plots.\nIncludes preview plus metadata about truncated rows/columns for quick table heads.","category":"section"},{"location":"api.html#Full-Docstrings","page":"API","title":"Full Docstrings","text":"","category":"section"},{"location":"api.html#DataProfiler.ColumnProfile","page":"API","title":"DataProfiler.ColumnProfile","text":"ColumnProfile\n\nSummary of a single column produced by profile_column and used inside ProfileReport.\n\nFields\n\nname::Symbol — column name.\neltype_str::String — element type as a string (pretty-printed eltype).\nn::Int — total length of the column.\nnmiss::Int — number of missing entries.\nnunique::Int — number of unique non-missing values.\nis_constant::Bool — whether all non-missing values are identical.\nis_numeric::Bool — whether values are numeric (after missing stripping).\nnotes::Vector{String} — semantic hints (e.g., likely ID, date-like, categorical).\nstats::Dict{Symbol,Float64} — numeric summary statistics (mean, std, quantiles…).\nascii_hist::String — ASCII histogram (UnicodePlots) for numeric data.\nascii_box::String — ASCII boxplot (UnicodePlots) for numeric data.\npng_hist_path::Union{Nothing,String} — path to PNG histogram if CairoMakie available.\npng_box_path::Union{Nothing,String} — path to PNG boxplot if CairoMakie available.\n\n\n\n\n\n","category":"type"},{"location":"api.html#DataProfiler.ProfileReport","page":"API","title":"DataProfiler.ProfileReport","text":"ProfileReport\n\nTop-level result of profile(df) that aggregates per-column profiles and dataset-level summaries.\n\nFields\n\nnrows::Int — number of rows in the profiled DataFrame.\nncols::Int — number of columns.\nsampled::Bool — whether rows were sampled to limit work/plots.\nsample_rows::Int — size of the sample actually used.\nprofiles::Vector{ColumnProfile} — per-column profiles.\noverall_missing::Dict{Symbol,Any} — totals and per-column missingness info.\nduplicates::Dict{Symbol,Any} — duplicate summary (row-wise or by keys).\npreview::DataFrame — head preview of the data (truncated rows/columns as needed).\npreview_rows::Int — number of rows shown in the preview.\npreview_cols::Int — number of columns shown in the preview.\npreview_truncated_rows::Bool — whether additional rows exist beyond the preview.\npreview_truncated_cols::Bool — whether additional columns exist beyond the preview.\noutdir::String — directory where artifacts (plots) are written.\n\n\n\n\n\n","category":"type"},{"location":"api.html#DataProfiler.dup_summary","page":"API","title":"DataProfiler.dup_summary","text":"dup_summary(df::DataFrame; by::Union{Nothing,Vector{Symbol}}=nothing)\n\nReport duplicate rows in df. When by is provided, duplicates are detected only with respect to those keys and a compact frequency table is returned.\n\nExamples\n\njulia> using DataProfiler, DataFrames\n\njulia> df = DataFrame(id = [1, 1, 2], value = [\"a\", \"a\", \"b\"]);\n\njulia> summary = dup_summary(df);\n\njulia> summary[:duplicate_count]\n1\n\njulia> summary[:indices]\n1-element Vector{Int64}:\n 2\n\njulia> dup_summary(df; by = [:id])[:duplicate_count]\n1\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.missing_summary","page":"API","title":"DataProfiler.missing_summary","text":"missing_summary(x::AbstractVector)\n\nSummarise missing entries in x.\n\nReturns a named tuple with the count of missings, their fraction, and the starting indices of the first few missing runs.\n\nExamples\n\njulia> using DataProfiler\n\njulia> missing_summary([1, missing, 2, missing, missing])\n(nmiss = 3, frac = 0.6, first_positions = [2, 4])\n\njulia> missing_summary(Int[])\n(nmiss = 0, frac = 0.0, first_positions = Int64[])\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.outlier_flags","page":"API","title":"DataProfiler.outlier_flags","text":"outlier_flags(x::AbstractVector{<:Real}; method::Symbol=:mad, z::Real=3.5)\n\nReturn a boolean mask that marks outliers in x using either the MAD or IQR rules. Missings and non-finite values are ignored.\n\nExamples\n\njulia> using DataProfiler\n\njulia> x = [1, 1, 2, 2, 100];\n\njulia> outlier_flags(x)\n5-element BitVector:\n 0\n 0\n 0\n 0\n 1\n\njulia> outlier_flags(x; method = :iqr, z = 1.5)\n5-element BitVector:\n 0\n 0\n 0\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.profile","page":"API","title":"DataProfiler.profile","text":"profile(df::DataFrame; sample_rows::Int=1000, maxplots::Int=8, outdir::AbstractString=\"profile_artifacts\", by::Union{Nothing,Vector{Symbol}}=nothing)\n\nGenerate a comprehensive data profile of df, with optional row sampling, full column profiling, and an assembled report of plots and summaries in a ProfileReport.\n\nPreview\n\nThe returned report now includes a head preview (report.preview) capped at 5 rows × 6 columns so the generated Markdown can display a compact glimpse of the data.\n\nExamples\n\njulia> using DataProfiler, DataFrames\n\njulia> df = DataFrame(a = randn(100), b = rand(1:3, 100));\n\njulia> report = profile(df; sample_rows = 50);\n\njulia> report.sampled\ntrue\n\njulia> using DataProfiler, DataFrames\n\njulia> df = DataFrame(id = repeat(1:3, inner = 2));\n\njulia> profile(df; by = [:id]).duplicates[:duplicate_count]\n3\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.profile_column","page":"API","title":"DataProfiler.profile_column","text":"profile_column(x::AbstractVector; name::Symbol, is_categorical::Bool=false)\n\nCompute a ColumnProfile with type information, summary statistics, semantic hints, and optional plots for the supplied column vector.\n\nExamples\n\njulia> using DataProfiler, DataFrames\n\njulia> df = DataFrame(a = [1, 2, 3, missing], b = [\"2024-01-01\", \"a\", \"b\", \"c\"]);\n\njulia> profile = profile_column(df.a; name = :a);\n\njulia> profile.stats[:mean]\n2.0\n\njulia> profile_column(df.b; name = :b).notes\n1-element Vector{String}:\n \"contains date-like strings (YYYY-MM-DD)\"\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.render_markdown","page":"API","title":"DataProfiler.render_markdown","text":"render_markdown(report::ProfileReport)\n\nCreate a Markdown string summarising the provided ProfileReport, including overall dataset notes and per-column sections with plots when available.\n\nExamples\n\njulia> using DataProfiler, DataFrames\n\njulia> df = DataFrame(x = 1:3);\n\njulia> report = profile(df);\n\njulia> markdown = render_markdown(report);\n\njulia> occursin(\"## Data Preview\", markdown)\ntrue\n\njulia> using DataProfiler, DataFrames\n\njulia> report = profile(DataFrame(x = [missing, 1, 2]));\n\njulia> render_markdown(report) |> isempty\nfalse\n\n\n\n\n\n","category":"function"},{"location":"api.html#DataProfiler.save_report","page":"API","title":"DataProfiler.save_report","text":"save_report(report::ProfileReport, path::AbstractString; fmt::Symbol=:auto)\n\nPersist an pr to disk as Markdown or HTML. When fmt == :auto the file extension decides the output format.\n\nExamples\n\njulia> using DataProfiler, DataFrames\n\njulia> report = profile(DataFrame(x = randn(20)));\n\njulia> save_report(report, \"report.md\")\n\njulia> isfile(\"report.md\")\ntrue\n\njulia> using DataProfiler, DataFrames\n\njulia> report = profile(DataFrame(x = randn(20)));\n\njulia> save_report(report, \"report.html\")\n\njulia> isfile(\"report.html\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"index.html#DataProfiler.jl","page":"Home","title":"DataProfiler.jl","text":"Generate a full data profile for a DataFrame in one function call, producing a compact, human-readable report (Markdown or HTML) with stat and plots.","category":"section"},{"location":"index.html#Quickstart","page":"Home","title":"Quickstart","text":"julia> using Pkg\njulia> Pkg.activate(\"./DataProfiler\"); Pkg.instantiate()\n\njulia> using DataProfiler, DataFrames\njulia> df = DataFrame(a = randn(200), b = rand(1:5, 200));\n\njulia> report = profile(df; sample_rows = 150, maxplots = 4);\n\njulia> save_report(report, \"report.md\")","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Missingness and duplicate summaries\nNumeric stats (mean, std, quantiles, skewness, kurtosis)\nASCII histograms/boxplots via UnicodePlots; optional PNG via CairoMakie\nAutomatic head preview (5×6) at the top of each report\nSemantic hints for string/date/categorical columns","category":"section"},{"location":"index.html#API","page":"Home","title":"API","text":"See the API page for full docstrings with examples.","category":"section"}]
}
